<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Investigation of Adaptive Piecewise Linear Approximation Algorithms: QuickStart</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Investigation of Adaptive Piecewise Linear Approximation Algorithms
   </div>
   <div id="projectbrief">Related algorithms and utilities for APLA and SimSearch</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QuickStart</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Contents</b></p><ul>
<li>Basic user guide.<ul>
<li>Construct, swap and base class reference</li>
<li>Let it work</li>
<li>Helper function</li>
</ul>
</li>
<li>Customize your own progress bar object<ul>
<li>By constructor</li>
<li>By member method</li>
</ul>
</li>
<li>Insight into the configuration types<ul>
<li>Basic configuration types</li>
<li>The base class of configuration types</li>
</ul>
</li>
<li>Insight into the progress bar types</li>
<li>Variable progress bar length</li>
<li>Variable animation rate</li>
<li>Thread safety<ul>
<li>Cross-thread call</li>
<li>Lock type</li>
</ul>
</li>
<li>Switching output stream</li>
<li>Design principle<ul>
<li>Basic architecture</li>
<li>About exception passing</li>
<li>Implementation principle of progress bar type and configuration</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md235"></a>
Basic user guide.</h1>
<h2><a class="anchor" id="autotoc_md236"></a>
Construct, swap and base class reference</h2>
<p>All progress bar objects can be constructed by default without parameters.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::BlockProgressBar&lt;&gt;</a> bpbar;</div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::SpinnerBar&lt;&gt;</a> spibar;</div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ScannerBar&lt;&gt;</a> scnbar;</div>
<div class="ttc" id="aclasspgbar_1_1BasicBar_html"><div class="ttname"><a href="classpgbar_1_1BasicBar.html">pgbar::BasicBar</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:5268</div></div>
</div><!-- fragment --><p>And these objects are movable, swappble but not copyable.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar2;</div>
<div class="line"> </div>
<div class="line">pbar = std::move( pbar2 ); <span class="comment">// movable</span></div>
<div class="line">swap( <a class="code hl_namespace" href="namespacepgbar.html">pgbar</a>, pbar2 );      <span class="comment">// swapable</span></div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">pbar.swap( pbar2 );</div>
<div class="ttc" id="anamespacepgbar_html"><div class="ttname"><a href="namespacepgbar.html">pgbar</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:140</div></div>
</div><!-- fragment --><p>The classes are derived from <code><a class="el" href="classpgbar_1_1Indicator.html">pgbar::Indicator</a></code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1Indicator.html">pgbar::Indicator</a>&amp; base_ref = pbar;</div>
<div class="ttc" id="aclasspgbar_1_1Indicator_html"><div class="ttname"><a href="classpgbar_1_1Indicator.html">pgbar::Indicator</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:5191</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md237"></a>
Let it work</h2>
<p>The <code>ProgressBar</code> and <code>BlockProgressBar</code> constructed by default cannot be used directly, it must be used only after passing a number of tasks to the method <code>config().tasks()</code>. Otherwise it will throw an exception <code><a class="el" href="classpgbar_1_1exception_1_1InvalidState.html">pgbar::exception::InvalidState</a></code>.</p>
<blockquote class="doxtable">
<p>&zwj;All exceptions in the library are derived from <code>std::exception</code>, and they all have a common base class, <code><a class="el" href="classpgbar_1_1exception_1_1Error.html">pgbar::exception::Error</a></code>. </p>
</blockquote>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  pbar.tick();</div>
<div class="line">} <span class="keywordflow">catch</span> ( <span class="keyword">const</span> <a class="code hl_class" href="classpgbar_1_1exception_1_1InvalidState.html">pgbar::exception::InvalidState</a>&amp; e ) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Oops! An exception occurs here: \&quot;&quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasspgbar_1_1exception_1_1InvalidState_html"><div class="ttname"><a href="classpgbar_1_1exception_1_1InvalidState.html">pgbar::exception::InvalidState</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:169</div></div>
</div><!-- fragment --><p>During iteration, you can use the <code>is_running()</code> and <code>progress()</code> methods to check whether the current progress bar is running and to get the number of times that <code>tick()</code> has been called so far.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"> </div>
<div class="line">pbar.config().tasks( 100 );</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> i = 0; i &lt; 100; ++i ) {</div>
<div class="line">  pbar.tick();</div>
<div class="line">  <span class="keywordflow">if</span> ( i == 99 ) <span class="comment">// The last call of `tick()` causes the progress bar to stop automatically</span></div>
<div class="line">    assert( !pbar.is_running() ); <span class="comment">// So the assert is not going to be true at that moment</span></div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    assert( pbar.is_running() );</div>
<div class="line">  assert( pbar.progress() != 0 );</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 20 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>As soon as' <code>tick()</code> is called as many times as the predetermined value of <code>config().tasks()</code>, the progress bar will stop running on its own. However, you can also call the <code>reset()</code> method of the progress bar in advance to actively stop the progress bar; If the progress bar object is destructed, it is equivalent to calling <code>reset()</code>.</p>
<p>Unlike the two progress bar types mentioned above, <code>SpinnerBar</code> and <code>ScannerBar</code> do not require the number of tasks to be specified and can be used directly.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::SpinnerBar&lt;&gt;</a> spibar;</div>
<div class="line"> </div>
<div class="line">spibar.tick();</div>
<div class="line">std::this_thread::sleep_for( std::chrono::seconds( 3 ) );</div>
<div class="line">spibar.<a class="code hl_function" href="classpgbar_1_1BasicBar.html#a317ddc05b19fd3d5ceb17eabd1a36513">reset</a>();</div>
<div class="ttc" id="aclasspgbar_1_1BasicBar_html_a317ddc05b19fd3d5ceb17eabd1a36513"><div class="ttname"><a href="classpgbar_1_1BasicBar.html#a317ddc05b19fd3d5ceb17eabd1a36513">pgbar::BasicBar::reset</a></div><div class="ttdeci">void reset() override final</div><div class="ttdef"><b>Definition</b> pgbar.hpp:5358</div></div>
</div><!-- fragment --><p>However, because there is no limit on the number of tasks, the work of the progress bar will not stop by itself, and the <code>reset()</code> method must be actively called at this time to stop rendering</p>
<h2><a class="anchor" id="autotoc_md238"></a>
Helper function</h2>
<p>Instead of manually specifying the number of tasks, you can use the <code>iterate()</code> method to make the progress bar work on an "abstract range", where the progress bar object will count the number of tasks itself.</p>
<p><code>iterate()</code> is used in a similar way to the <code>range()</code> function in Python.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::BlockProgressBar&lt;&gt;</a> bpbar;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Iterate over a range of values with BlockProgressBar: &quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; _ : bpbar.iterate( 50 ) ) {</div>
<div class="line">  <span class="comment">// Iterate over the numeric interval [0, 50) with step size 1</span></div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 40 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>iterate()</code> method can also work on a data container, such as an array.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::BlockProgressBar&lt;&gt;</a> bpbar;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Iterate over a raw array with BlockProgressBar: &quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span> arr[100] { 0 };</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; e : bpbar.iterate( arr ) ) {</div>
<div class="line">  e = 114514; <span class="comment">// access the elements directly within a loop</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> baseline = std::vector&lt;int&gt;( 100, 114514 );</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Are the values in these two ranges equal? &quot;</span> &lt;&lt; std::boolalpha</div>
<div class="line">          &lt;&lt; std::equal( arr, arr + 100, baseline.cbegin() ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You can also pass two iterators to <code>iterate()</code> for the iterated range; If it is an iterator of pointer type, it can be accessed in reverse order by inverting the starting and ending points.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::SpinnerBar&lt;&gt;</a> spibar;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Reverse iterate over a raw array with SpinnerBar: &quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; _ : spibar.iterate( arr + 100, arr ) ) {</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 20 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The data container here also contains the generic container in the STL, such as <code>std::vector</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ScannerBar&lt;&gt;</a> scnbar;</div>
<div class="line"><span class="comment">// The baseline here appears above</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Iterate over an object of std::vector with ScannerBar: &quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; _ : scnbar.iterate( baseline ) ) {</div>
<div class="line">  <span class="comment">// do something here...</span></div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 20 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>iterate()</code> can also accept a unary function and act on the element in the range, as can <code>std::for_each</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ScannerBar&lt;&gt;</a> scnbar;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Iterate over an object of std::vector with an unary function: &quot;</span>;</div>
<div class="line">std::vector&lt;char&gt; alphabet( 26 );</div>
<div class="line">std::iota( alphabet.begin(), alphabet.end(), <span class="charliteral">&#39;a&#39;</span> );</div>
<div class="line">scnbar.iterate( alphabet, []( <span class="keywordtype">char</span> ) { <span class="comment">/*...*/</span> } );</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md239"></a>
Customize your own progress bar object</h1>
<h2><a class="anchor" id="autotoc_md240"></a>
By constructor</h2>
<p>All types of progress bars can be constructed as modified objects from the default configuration by passing in no less than one <code>pgbar::option</code> wrapper type.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar { <a class="code hl_struct" href="structpgbar_1_1option_1_1Style.html">pgbar::option::Style</a>( <span class="comment">// Select a different progress bar information section</span></div>
<div class="line">                              pgbar::config::CharBar::Per | pgbar::config::CharBar::Elpsd ),</div>
<div class="line">                            <a class="code hl_struct" href="structpgbar_1_1option_1_1InfoColor.html">pgbar::option::InfoColor</a>( pgbar::color::Red ), <span class="comment">// Change the color of the information section</span></div>
<div class="line">                            <a class="code hl_struct" href="structpgbar_1_1option_1_1Tasks.html">pgbar::option::Tasks</a>( 100 ) };</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> _ = 0; _ &lt; 100; ++_ ) {</div>
<div class="line">  pbar.tick();</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 20 ) );</div>
<div class="line">}</div>
<div class="ttc" id="astructpgbar_1_1option_1_1InfoColor_html"><div class="ttname"><a href="structpgbar_1_1option_1_1InfoColor.html">pgbar::option::InfoColor</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2777</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1Style_html"><div class="ttname"><a href="structpgbar_1_1option_1_1Style.html">pgbar::option::Style</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2594</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1Tasks_html"><div class="ttname"><a href="structpgbar_1_1option_1_1Tasks.html">pgbar::option::Tasks</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2609</div></div>
</div><!-- fragment --><p>It is not allowed to pass a duplicate <code>pgbar::option</code> type, otherwise it will cause compilation error.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::SpinnerBar&lt;&gt;</a> spibar { <a class="code hl_struct" href="structpgbar_1_1option_1_1Lead.html">pgbar::option::Lead</a>( { <span class="stringliteral">&quot;◜&quot;</span>, <span class="stringliteral">&quot;◝&quot;</span>, <span class="stringliteral">&quot;◞&quot;</span>, <span class="stringliteral">&quot;◟&quot;</span> } ),</div>
<div class="line">                             <a class="code hl_struct" href="structpgbar_1_1option_1_1Description.html">pgbar::option::Description</a>( <span class="stringliteral">&quot;Loading...&quot;</span> ),</div>
<div class="line">                             <a class="code hl_struct" href="structpgbar_1_1option_1_1DescColor.html">pgbar::option::DescColor</a>( <span class="stringliteral">&quot;#FFF&quot;</span> ),</div>
<div class="line">                             <a class="code hl_struct" href="structpgbar_1_1option_1_1DescColor.html">pgbar::option::DescColor</a>( <span class="stringliteral">&quot;#39C5BB&quot;</span> ) };</div>
<div class="line"><span class="comment">// Compilation Error!</span></div>
<div class="ttc" id="astructpgbar_1_1option_1_1DescColor_html"><div class="ttname"><a href="structpgbar_1_1option_1_1DescColor.html">pgbar::option::DescColor</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2737</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1Description_html"><div class="ttname"><a href="structpgbar_1_1option_1_1Description.html">pgbar::option::Description</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2693</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1Lead_html"><div class="ttname"><a href="structpgbar_1_1option_1_1Lead.html">pgbar::option::Lead</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2842</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md241"></a>
By member method</h2>
<p>In addition to the fact that the constructor can use multiple variable <code>pgbar::option</code> wrappers, the member method <code>config().set()</code> can also accept arguments of this form.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::SpinnerBar&lt;&gt;</a> spibar;</div>
<div class="line"> </div>
<div class="line">spibar.config().set( <a class="code hl_struct" href="structpgbar_1_1option_1_1InfoColor.html">pgbar::option::InfoColor</a>( <span class="stringliteral">&quot;#FFA500&quot;</span> ),</div>
<div class="line">                     <a class="code hl_struct" href="structpgbar_1_1option_1_1Style.html">pgbar::option::Style</a>( pgbar::config::CharBar::Sped | pgbar::config::CharBar::Per</div>
<div class="line">                                            | pgbar::config::CharBar::Elpsd</div>
<div class="line">                                            | pgbar::config::CharBar::Cntdwn ),</div>
<div class="line">                     <a class="code hl_struct" href="structpgbar_1_1option_1_1SpeedUnit.html">pgbar::option::SpeedUnit</a>( { <span class="stringliteral">&quot;B/s&quot;</span>, <span class="stringliteral">&quot;kB/s&quot;</span>, <span class="stringliteral">&quot;MB/s&quot;</span>, <span class="stringliteral">&quot;GB/s&quot;</span> } ),</div>
<div class="line">                     <a class="code hl_struct" href="structpgbar_1_1option_1_1Tasks.html">pgbar::option::Tasks</a>( 70 ) );</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> i = 0; i &lt; 70; ++i ) {</div>
<div class="line">  spibar.tick();</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 70 - i ) );</div>
<div class="line">}</div>
<div class="ttc" id="astructpgbar_1_1option_1_1SpeedUnit_html"><div class="ttname"><a href="structpgbar_1_1option_1_1SpeedUnit.html">pgbar::option::SpeedUnit</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2802</div></div>
</div><!-- fragment --><p>All types/methods used to configure colors can receive valid RGB color codes as strings, or RGB color values given directly as hexadecimal integers.</p>
<p>And color effects can be forcibly turned off by defining a <code>PGBAR_COLORLESS</code> macro.</p>
<p>In addition, <code>config()</code> itself provides a streaming interface style, which can also configure different parts of the progress bar style one by one.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::SpinnerBar&lt;&gt;</a> spibar;</div>
<div class="line"> </div>
<div class="line">spibar.config()</div>
<div class="line">      .bolded( <span class="keyword">false</span> )</div>
<div class="line">      .info_color( 0xFFE211 )</div>
<div class="line">      .speed_unit( { <span class="stringliteral">&quot;Actually&quot;</span>, <span class="stringliteral">&quot;you can write&quot;</span>, <span class="stringliteral">&quot;anything&quot;</span>, <span class="stringliteral">&quot;here&quot;</span> } )</div>
<div class="line">      .divider( <span class="stringliteral">&quot; &gt;&lt; &quot;</span> )</div>
<div class="line">      .left_border( <span class="stringliteral">&quot;&lt; &quot;</span> )</div>
<div class="line">      .right_border( <span class="stringliteral">&quot; &gt;&quot;</span> )</div>
<div class="line">      .tasks( 1000 );</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> i = 0; i &lt; 1000; ++i ) {</div>
<div class="line">  spibar.tick();</div>
<div class="line">  <span class="keywordflow">if</span> ( i == 499 )</div>
<div class="line">    std::this_thread::sleep_for( std::chrono::seconds( 3 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md242"></a>
Insight into the configuration types</h1>
<h2><a class="anchor" id="autotoc_md243"></a>
Basic configuration types</h2>
<p>In fact, the return value of the <code>config()</code> method is a reference to a configuration object held inside the progress bar object, whose type can be found in <code>pgbar::config</code>; Each progress bar type has only one configuration type corresponding to it.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::CharBar</a> pbar_cfg;   <span class="comment">// config type of ProgressBar</span></div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::BlckBar</a> bpbar_cfg;  <span class="comment">// config type of BlockProgressBar</span></div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::SpinBar</a> spibar_cfg; <span class="comment">// config type of SpinnerBar</span></div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::ScanBar</a> scnbar_cfg; <span class="comment">// config type of ScannerBar</span></div>
<div class="ttc" id="aclasspgbar_1_1config_1_1BasicConfig_html"><div class="ttname"><a href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::BasicConfig</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:4337</div></div>
</div><!-- fragment --><p>All these configuration types are copyable, movable and swappble.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::CharBar</a> pbar_cfg;</div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::CharBar</a> pbar_cfg2;</div>
<div class="line"> </div>
<div class="line">pbar_cfg = pbar_cfg2;              <span class="comment">// copyable</span></div>
<div class="line">pbar_cfg = std::move( pbar_cfg2 ); <span class="comment">// movable</span></div>
<div class="line">swap( pbar_cfg, pbar_cfg2 );       <span class="comment">// swapable</span></div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">pbar_cfg.swap( pbar_cfg2 );</div>
</div><!-- fragment --><p>You can pass a configuration object directly to the constructor of the progress bar object to create a new progress bar based on existing configuration information.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar { pbar_cfg };</div>
<div class="line"><span class="comment">// Or reassign the internal configuration type using the config() method</span></div>
<div class="line">pbar.config() = pbar_cfg;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The constructor of the configuration object itself also supports variable argument lists</span></div>
<div class="line"><span class="comment">// so you can also change the configuration object in this way</span></div>
<div class="line">pbar.config() = { <a class="code hl_struct" href="structpgbar_1_1option_1_1InfoColor.html">pgbar::option::InfoColor</a>( pgbar::color::Red ), <a class="code hl_struct" href="structpgbar_1_1option_1_1Tasks.html">pgbar::option::Tasks</a>( 100 ) };</div>
<div class="line"><span class="comment">// This is equivalent to pbar.config().swap( another_config )</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md244"></a>
The base class of configuration types</h2>
<p>These types are derived from <code><a class="el" href="classpgbar_1_1config_1_1Core.html">pgbar::config::Core</a></code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::CharBar</a> pbar_cfg;</div>
<div class="line"><a class="code hl_class" href="classpgbar_1_1config_1_1Core.html">pgbar::config::Core</a>&amp; base_ref = pbar_cfg;</div>
<div class="ttc" id="aclasspgbar_1_1config_1_1Core_html"><div class="ttname"><a href="classpgbar_1_1config_1_1Core.html">pgbar::config::Core</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:4278</div></div>
</div><!-- fragment --><p>This base class also stores some configuration data related to the underlying settings.</p>
<p>For example, the refresh rate of progress bar objects in the terminal interface is controlled by the return value of <code>pgbar::config::Core::refresh_interval()</code>, and <code><a class="el" href="classpgbar_1_1config_1_1Core.html">pgbar::config::Core</a></code> allows you to modify the basic configuration data at run time.</p>
<div class="fragment"><div class="line"><span class="comment">// Increase the refresh rate from the default 25 Hz to 60 Hz</span></div>
<div class="line">pgbar::config::Core::refresh_interval( std::chrono::milliseconds( 20 ) );</div>
</div><!-- fragment --><p>This method actually requires the progress bar object to sleep for 20 milliseconds after each output to the console; Shorter refresh intervals mean smoother animations, but also a higher single-core CPU load.</p>
<p>However, since the time of each rendering output cannot be 0, this method is essentially controlling the minimum interval of rendering output can not be lower than the given value.</p>
<p>You can also use <code>pgbar::config::Core::intty()</code> method to learn the standard output stream of the current process is binding on the terminal, it need to combine the enumeration <code>pgbar::Channel</code> values to determine which is you need to check the output stream; For example, check the standard output stream <code>stdout</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( pgbar::config::Core::intty( pgbar::Channel::Stdout ) )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Standard output is bound to a terminal.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Standard output is not bound to a terminal.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You can define a <code>PGBAR_INTTY</code> macro before the include file to force the <code>pgbar::config::Core::intty()</code> method to always return <code>true</code>.</p>
<h1><a class="anchor" id="autotoc_md245"></a>
Insight into the progress bar types</h1>
<p>As mentioned earlier, all progress bar types are highly similar, with the only differences being the behavior when the <code>tick()</code> method is called, the arguments the constructor can accept, and the kinds of methods that can be chain-called when the <code>config()</code> method is called.</p>
<p>In addition to <code>is_running()</code>, <code>progress()</code>, and <code>iterate()</code> mentioned earlier, the progress bar object has several useful methods; Take <code>ProgressBar</code> as an example.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar { <a class="code hl_struct" href="structpgbar_1_1option_1_1Tasks.html">pgbar::option::Tasks</a>( 100 ),</div>
<div class="line">                            <a class="code hl_struct" href="structpgbar_1_1option_1_1Description.html">pgbar::option::Description</a>( <span class="stringliteral">&quot;Doing sth...&quot;</span> ),</div>
<div class="line">                            <a class="code hl_struct" href="structpgbar_1_1option_1_1TrueMesg.html">pgbar::option::TrueMesg</a>( <span class="stringliteral">&quot;✔ Mission Complete!&quot;</span> ),</div>
<div class="line">                            <a class="code hl_struct" href="structpgbar_1_1option_1_1TrueColor.html">pgbar::option::TrueColor</a>( pgbar::color::Green ),</div>
<div class="line">                            <a class="code hl_struct" href="structpgbar_1_1option_1_1FalseMesg.html">pgbar::option::FalseMesg</a>( <span class="stringliteral">&quot;✖ Execution Failure!&quot;</span> ),</div>
<div class="line">                            <a class="code hl_struct" href="structpgbar_1_1option_1_1FalseColor.html">pgbar::option::FalseColor</a>( pgbar::color::Red ) };</div>
<div class="line">pbar.tick();         <span class="comment">// Make the progress bar advance one step</span></div>
<div class="line">pbar.<a class="code hl_function" href="classpgbar_1_1BasicBar.html#a317ddc05b19fd3d5ceb17eabd1a36513">reset</a>();        <span class="comment">// Reset the progress bar and immediately terminate rendering while displaying TrueMesg&#39;s contents</span></div>
<div class="line">pbar.<a class="code hl_function" href="classpgbar_1_1BasicBar.html#aa27ae4c536f1cd3283b6199f14e6f87a">tick_to</a>( 50 );  <span class="comment">// Make the progress bar progress to 50%</span></div>
<div class="line">pbar.tick( 3 );      <span class="comment">// Make the progress bar advance three steps</span></div>
<div class="line">pbar.<a class="code hl_function" href="classpgbar_1_1BasicBar.html#a317ddc05b19fd3d5ceb17eabd1a36513">reset</a>( <span class="keyword">false</span> ); <span class="comment">// Reset the progress bar and immediately terminate rendering while displaying FalseMesg&#39;s contents</span></div>
<div class="ttc" id="aclasspgbar_1_1BasicBar_html_aa27ae4c536f1cd3283b6199f14e6f87a"><div class="ttname"><a href="classpgbar_1_1BasicBar.html#aa27ae4c536f1cd3283b6199f14e6f87a">pgbar::BasicBar::tick_to</a></div><div class="ttdeci">Self &amp; tick_to(__details::types::Size percentage) &amp;override final</div><div class="ttdef"><b>Definition</b> pgbar.hpp:5334</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1FalseColor_html"><div class="ttname"><a href="structpgbar_1_1option_1_1FalseColor.html">pgbar::option::FalseColor</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2747</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1FalseMesg_html"><div class="ttname"><a href="structpgbar_1_1option_1_1FalseMesg.html">pgbar::option::FalseMesg</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2703</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1TrueColor_html"><div class="ttname"><a href="structpgbar_1_1option_1_1TrueColor.html">pgbar::option::TrueColor</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2742</div></div>
<div class="ttc" id="astructpgbar_1_1option_1_1TrueMesg_html"><div class="ttname"><a href="structpgbar_1_1option_1_1TrueMesg.html">pgbar::option::TrueMesg</a></div><div class="ttdef"><b>Definition</b> pgbar.hpp:2698</div></div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<code>TrueMesg</code> and <code>FalseMesg</code> are part of the <code>Description</code> element and appear only before the progress bar is about to stop working and are used to replace the predefined description with a custom one. \ Which information is displayed depends on the <code>bool</code> parameter passed when the <code>reset()</code> method is called; <code>TrueMesg</code> is selected by default. </p>
</blockquote>
<p>Note: If the progress bar object is destructed, <code>TrueMesg</code> or <code>FalseMesg</code> are not rendered, even if they have been written to the configuration object.</p>
<blockquote class="doxtable">
<p>&zwj;In the destructor scenario, stopping work immediately and releasing all resources is considered a top priority. </p>
</blockquote>
<div class="fragment"><div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Be deconstructed while rendering.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::SpinnerBar&lt;&gt;</a> spibar { <a class="code hl_struct" href="structpgbar_1_1option_1_1Description.html">pgbar::option::Description</a>( <span class="stringliteral">&quot;???&quot;</span> ),</div>
<div class="line">                               <a class="code hl_struct" href="structpgbar_1_1option_1_1TrueMesg.html">pgbar::option::TrueMesg</a>( <span class="stringliteral">&quot;!!!&quot;</span> ),</div>
<div class="line">                               <a class="code hl_struct" href="structpgbar_1_1option_1_1FalseMesg.html">pgbar::option::FalseMesg</a>( <span class="stringliteral">&quot;///&quot;</span> ) };</div>
<div class="line">  spibar.tick();</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::seconds( 3 ) );</div>
<div class="line">} <span class="comment">// spibar is destructed here and rendering stops immediately</span></div>
<div class="line"><span class="comment">// so we have to add a newline</span></div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>In addition to configuring all the information for the progress bar before the task starts, you can also dynamically modify the information in the progress bar while it is running.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"> </div>
<div class="line">pbar.config().tasks( 5 );</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> i = 0; i &lt; 5; ++i ) {</div>
<div class="line">  pbar.tick();</div>
<div class="line">  pbar.config().description( <span class="stringliteral">&quot;Working process (&quot;</span> + std::to_string( i + 1 ) + <span class="stringliteral">&quot;/5)&quot;</span> );</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 1500 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>But changing the number of tasks is <b>not effective</b>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"> </div>
<div class="line">pbar.config().tasks( 100 );</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> i = 0; i &lt; 100; ++i ) {</div>
<div class="line">  pbar.tick();</div>
<div class="line">  <span class="keywordflow">if</span> ( i == 30 )</div>
<div class="line">    pbar.config().tasks( 50 );</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::milliseconds( 20 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you wish, you can also "gradient" the color of the progress bar like this.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;&gt;</a> pbar;</div>
<div class="line"> </div>
<div class="line">pbar.config().description( <span class="stringliteral">&quot;Rainbow&quot;</span> ).tasks( 0xFFFFFF + 1 );</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> i = 0; i &lt; 0xFFFFFF + 1; ++i ) {</div>
<div class="line">  pbar.tick();</div>
<div class="line">  pbar.config().info_color( i );</div>
<div class="line">  std::this_thread::sleep_for( std::chrono::microseconds( 30 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md246"></a>
Variable progress bar length</h1>
<p>In particular, the length of the bar indicator can be changed for <code>ProgressBar</code>, <code>BlockProgressBar</code> and <code>ScannerBar</code>; Take <code>ScannerBar</code> as an example.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ScannerBar&lt;&gt;</a> scnbar;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The counting unit of config().bar_length() is &quot;character&quot;</span></div>
<div class="line"><span class="comment">// That is, the value you pass in represents the number of characters that the bar indicator occupies in the terminal</span></div>
<div class="line">scnbar.config().bar_length( 20 );</div>
<div class="line">scnbar.tick();</div>
<div class="line">std::this_thread::sleep_for( std::chrono::seconds( 2 ) );</div>
<div class="line">scnbar.<a class="code hl_function" href="classpgbar_1_1BasicBar.html#a317ddc05b19fd3d5ceb17eabd1a36513">reset</a>();</div>
</div><!-- fragment --><p>If you can get the horizontal width of the current terminal window, then you can also calculate a length that allows the progress bar to "fill" a row.</p>
<p>You can get the length of the progress bar section except for the bar indicator by calling <code>config().fixed_size()</code> and calculate it as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef _WIN32 </span><span class="comment">// Windows</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> terminal_width = []() {</div>
<div class="line">  HANDLE hConsole = GetStdHandle( STD_OUTPUT_HANDLE );</div>
<div class="line">  CONSOLE_SCREEN_BUFFER_INFO csbi;</div>
<div class="line">  <span class="keywordflow">if</span> ( GetConsoleScreenBufferInfo( hConsole, &amp;csbi ) ) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> width = csbi.srWindow.Right - csbi.srWindow.Left + 1;</div>
<div class="line">    <span class="keywordflow">return</span> width == 0 ? 120 : width;</div>
<div class="line">  } <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> 120;</div>
<div class="line">}();</div>
<div class="line"><span class="preprocessor">#elif defined( __unix__ ) </span><span class="comment">// Linux</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> terminal_width = []() {</div>
<div class="line">  <span class="keyword">struct </span>winsize w;</div>
<div class="line">  <span class="keywordflow">if</span> ( ioctl( STDOUT_FILENO, TIOCGWINSZ, &amp;w ) == -1 )</div>
<div class="line">    <span class="keywordflow">return</span> 120;</div>
<div class="line">  <span class="keywordflow">return</span> w.ws_col == 0 ? 120 : w.ws_col;</div>
<div class="line">}();</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> terminal_width = 120; <span class="comment">// Assuming terminal width is 120</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> total_length_excluding_bar = scnbar.config().fixed_size();</div>
<div class="line">scnbar.config().bar_length( terminal_width - total_length_excluding_bar );</div>
<div class="line"><span class="comment">// config().bar_length() itself also returns the length of the bar indicator for the current progress bar</span></div>
<div class="line"> </div>
<div class="line">scnbar.tick();</div>
<div class="line">std::this_thread::sleep_for( std::chrono::seconds( 5 ) );</div>
<div class="line">scnbar.<a class="code hl_function" href="classpgbar_1_1BasicBar.html#a317ddc05b19fd3d5ceb17eabd1a36513">reset</a>();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md247"></a>
Variable animation rate</h1>
<p>For <code>ProgressBar</code>, <code>SpinnerBar</code> and <code>ScannerBar</code>, the motion rate of their component <code>Lead</code> part is variable.</p>
<p>This variable rate can be adjusted by the type wrapper <code><a class="el" href="structpgbar_1_1option_1_1Shift.html">pgbar::option::Shift</a></code> and the method <code>config().shift()</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ScannerBar&lt;&gt;</a> scnbar;</div>
<div class="line">scnbar.config().shift( 2 ); <span class="comment">// Switch to 2x speed</span></div>
<div class="line">scnbar.tick();</div>
<div class="line">std::this_thread::sleep_for( std::chrono::seconds( 5 ) );</div>
<div class="line">scnbar.<a class="code hl_function" href="classpgbar_1_1BasicBar.html#a317ddc05b19fd3d5ceb17eabd1a36513">reset</a>();</div>
</div><!-- fragment --><p><code>Shift</code> is between -128 and 127; If the value k is negative, it means that the rate is adjusted to 1/k of the normal case, otherwise it is k times the normal case.</p>
<p>In fact, the effect is equivalent to change <code>pgbar::config::Core::refresh_interval()</code>; However, the effect of <code>Shift</code> only applies to local progress bar objects.</p>
<h1><a class="anchor" id="autotoc_md248"></a>
Thread safety</h1>
<h2><a class="anchor" id="autotoc_md249"></a>
Cross-thread call</h2>
<p>First, any type of method in <code>pgbar::config</code> is thread-safe, including replacing the configuration object itself with the <code>config()</code> method; This means that you can configure different parameters for another thread's progress bar object in another thread.</p>
<p>Second, the progress bar object itself is "optional" thread-safe, and this optionality is reflected in the template parameters of the progress bar object. For all progress bar objects that use the default construction, they are equivalent to the following declaration statement:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;pgbar::Threadunsafe&gt;</a> unsafe_bar;</div>
</div><!-- fragment --><p>For thread-unsafe progress bar objects, calling any method other than <code>config()</code> is thread-unsafe.</p>
<p>Using the <code>pgbar::Threadsafe</code> parameter, you can create a thread-safe progress bar object.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;pgbar::Threadsafe&gt;</a> safe_bar;</div>
</div><!-- fragment --><p>For the thread-safe version, you can call its <code>tick()</code> and <code>reset()</code> methods from as many threads as you want; However, it is still thread-unsafe for <code>swap()</code>, <code>iterate()</code>, and <code>operator=()</code>.</p>
<div class="fragment"><div class="line">safe_bar = <a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;pgbar::Threadsafe&gt;</a>(); <span class="comment">// Thread Unsafe!</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md250"></a>
Lock type</h2>
<p><code>pgbar::Threadsafe</code> is just a lock class that satisfies the Basic Locakable requirement. You can use another lock type instead of this parameter type. For example <code>std::mutex</code>.</p>
<blockquote class="doxtable">
<p>&zwj;In contrast, the thread-safe version of the progress bar has an additional overhead than the less secure version, an overhead that cannot be resolved by introducing a more lightweight lock type. </p>
</blockquote>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ProgressBar&lt;std::mutex&gt;</a> safe_bar;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> iteration   = 2147483648;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> num_threads = 4;</div>
<div class="line">safe_bar.config().tasks( iteration );</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::thread&gt; threads;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> _ = 0; _ &lt; num_threads; ++_ ) {</div>
<div class="line">  threads.emplace_back( [&amp;]() {</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> _ = 0; _ &lt; iteration / num_threads; ++_ ) {</div>
<div class="line">      safe_bar.tick();</div>
<div class="line">    }</div>
<div class="line">  } );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp; td : threads ) {</div>
<div class="line">  <span class="keywordflow">if</span> ( td.joinable() )</div>
<div class="line">    td.join();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">safe_bar.wait();</div>
</div><!-- fragment --><p>Notice that a <code>wait()</code> method is called at the end of the previous code; This is because in a multithreaded environment, if the thread holding the progress bar object leaves the scope of the progress bar, the progress bar rendering will immediately stop because of the destructor.</p>
<p>So the progress bar object provides <code>wait()</code> and <code>wait_for()</code> methods to block the current thread until the progress bar is stopped.</p>
<p>But the blocking effect only takes effect after the first <code>tick()</code> method is called; So in a multithreaded environment, the optimal solution is to wait for all child threads to finish before calling the <code>wait()</code> or <code>wait_for()</code> method.</p>
<h1><a class="anchor" id="autotoc_md251"></a>
Switching output stream</h1>
<p>By default, the progress bar object outputs a string to the current process's standard error stream <code>stderr</code>; The destination of the output stream can be changed by the template type parameter passed to the progress bar when the progress bar object is created.</p>
<p>For example, create a progress bar object that outputs to <code>stdout</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classpgbar_1_1BasicBar.html">pgbar::ScannerBar&lt;pgbar::Threadunsafe, pgbar::Channel::Stdout&gt;</a> scnbar;</div>
</div><!-- fragment --><p>The progress bar itself does not monopolize a standard output stream of the current process at any point in time, so output information to the standard output stream bound to the progress bar during progress bar work will cause the string rendered by the terminal to be distorted.</p>
<p>If an output stream is not bound to the terminal, the progress bar does not write any data to the output stream file, but the exception check and task iteration count proceed normally.</p>
<blockquote class="doxtable">
<p>&zwj;To check whether an output stream is bound to a terminal, you can use the <code>pgbar::config::Core::intty()</code> method mentioned earlier. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md252"></a>
Design principle</h1>
<h2><a class="anchor" id="autotoc_md253"></a>
Basic architecture</h2>
<p>The progress bar consists of two main parts: the notification thread and the rendering thread. The notification thread is the thread responsible for calling the <code>tick()</code> method each time, while the render thread is a thread object managed by the thread manager <code><a class="el" href="classpgbar_1_1____details_1_1render_1_1Renderer.html">pgbar::__details::render::Renderer</a></code>.</p>
<p>Each notification thread's first call to <code>tick()</code> wakes up the rendering thread; Since thread managers are designed as lazy initialization, the first call of each progress bar object at the global scope also attempts to initialize the thread manager, i.e., create a child thread.</p>
<p>Each time the <code>reset()</code> method is called, the progress bar object suspends the rendering thread through the thread manager's member methods.</p>
<p>In order to ensure that the working state of the rendering thread is always valid, only the first <code>tick()</code> and the last <code>tick()</code>, or when the <code>reset()</code> is called at run, the notification thread will use a spin lock to wait for the rendering thread to transfer to the specified state; That is to say, only in the above three time points, the notification thread will block for an indefinite length.</p>
<h2><a class="anchor" id="autotoc_md254"></a>
About exception passing</h2>
<p>Since the rendering thread needs to repeatedly concatenate strings and write data to the standard output stream, it is possible to throw exceptions throughout the process.</p>
<p>If in Windows platform, the program can't get to the current process flow standard output Handle, the render thread throws a local system error exception <code><a class="el" href="classpgbar_1_1exception_1_1SystemError.html">pgbar::exception::SystemError</a></code>; In a more general case, if the current machine is running low on resources (e.g., out of memory), a library exception such as <code>std::bad_alloc</code> will be thrown by the standard library at any memory request point.</p>
<p>The rest of the case, if the rendering thread received a thrown exception, it will be the exception is stored in the internal <code><a class="el" href="classpgbar_1_1____details_1_1concurrent_1_1ExceptionBox.html">pgbar::__details::concurrent::ExceptionBox</a></code> container, and stop the current render job; Wait until the next time the notification thread calls <code>activate()</code> or <code>suspend()</code> the caught exception is re-thrown in the notification thread.</p>
<blockquote class="doxtable">
<p>&zwj;<code>activate()</code> and <code>suspend()</code> are called only on the first and last <code>tick()</code> and <code>reset()</code> methods of the progress bar. </p>
</blockquote>
<p>If the rendering thread already has an unhandled exception in its exception container, and another exception is thrown inside the thread, the rendering thread will enter a <code>dead</code> state. In this state, new exceptions are not caught, but are allowed to propagate until the rendering thread terminates.</p>
<p>In the <code>dead</code> state, recalling the thread manager's <code>activate()</code> method (i.e. reactivating the progress bar object) will attempt to pull up a new rendering thread; During this process, the last unhandled exception will be thrown before a new rendering thread is created and can start working.</p>
<h2><a class="anchor" id="autotoc_md255"></a>
Implementation principle of progress bar type and configuration</h2>
<p>As mentioned earlier, the functionality of the different types of progress bars is highly similar, except that their semantic expression and rendering styles differ at runtime.</p>
<p>In fact, all progress bar types are aliases of the template class <code><a class="el" href="classpgbar_1_1BasicBar.html">pgbar::BasicBar</a></code>; Similarly, all configuration type is <code><a class="el" href="classpgbar_1_1config_1_1BasicConfig.html">pgbar::config::BasicConfig</a></code> alias.</p>
<p>By <a href="https://zhuanlan.zhihu.com/p/106672814">this article</a>, the progress bar follow a Mixin pattern combination inherited from <code>pgbar::__details::assets</code> the different template base class; All template classes in <code>pgbar::__details::assets</code> are designed in CRTP mode, so a whole bunch of methods for configuring data can be called through the <code>config()</code> method chain for final use.</p>
<p>The Mixin pattern here owes much to a compile-time topological sorting algorithm called <code><a class="el" href="structpgbar_1_1____details_1_1traits_1_1TopoSort.html">pgbar::__details::traits::TopoSort</a></code>.</p>
<p>This topological sorting algorithm is similar to the C3 linearization algorithm in Python, but unlike it: The purpose of C3 linearization algorithm is to find the most suitable class method in the class inheritance structure, while the topological sorting algorithm here linearizes the entire inheritance structure directly, linearizing a complex multi-inheritance structure into an inheritance chain at compile time.</p>
<p>But they have one thing in common: the method resolution at the most derived class satisfies the local priority principle of the inheritance order of the base class; In other words, during the inheritance process, the base class located to the left of the inheritance list is preferentially placed closer to the derived class to ensure that the methods of this base class are not overwritten by the base class further to the right.</p>
<p>In addition, the topological sorting algorithm has another feature: for the two classes with non-virtual inheritance relationship, they will be placed as close to each other as possible after sorting; This is to ensure that in non-virtual inheritance, derived classes can refer directly to base classes without complex template nesting.</p>
<p>The specific working principle can be referred to the article mentioned above. Based on the principle proposed in the article, I have implemented a topological sorting algorithm that can analyze the relationship between virtual inheritance and non-virtual inheritance at the same time and meet some characteristics of C3 linearization algorithm. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
